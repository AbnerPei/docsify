# 为什么要设计metaClass？

Smalltalk更注重的是消息传递，是动态响应消息。

Objective-C的特性基本上是照搬的Smalltalk。

> 走到这里一套方法发送的流程就都走完了，那这跟元类的存在有啥关系？我们都知道类方法是存储在元类中的，那么可不可以把元类干掉，在类中把实例方法和类方法存在两个不同的副本中？
>
> 答：行是肯定可行的，但是在lookUpImpOrForward执行的时候就得标注上预期的cls到底是实例对象还是类对象，这也就意味着在查找方法的缓存时同样也需要判断cls到底是个啥。
> 
> 倘若该该类存在同名的类方法和实例方法是该调用该方法呢？这也就意味着还得给给的该方法带上是类方法还是实例方法的标识，SEL并没有带上当前方法的类型（实例方法还是类方法），参数又多加一个，而我们现在的objc_msgSend()只接收了（id self，SEL _cmd，...）这类型参数，第一个自我就是消息的接收者，第二个就是方法，后续的...就是各式各样的参数。
>
> 通过元类就可以准确的解决上述问题，让各类各司其职，实例对象就干存储属性值的事，类对象存储实例方法列表，元类对象存储类方法列表，完美的符合6大设计原则中的单一职责，而且忽略了对对象类型的判断和方法类型的判断可以大大的提升消息发送的效率，并且在不同种类的方法走的都是相同套流程，在之后的维护上也很大节约了成本。


## 参考链接
- **[Why is MetaClass in Objective-C？](https://www.jianshu.com/p/ea7c42e16da8)**
- **[为什么要设计metaclass](https://www.jianshu.com/p/7dfe5b369558)**